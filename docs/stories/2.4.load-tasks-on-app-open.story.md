# Story 2.4: Load Tasks on App Open

## Status
Done

## Story
**As a** user,  
**I want to** see all my tasks when I open the app,  
**So that** I can review what I've captured

## Acceptance Criteria
1. On MainScreen mount, query: `SELECT * FROM tasks WHERE user_id = ? AND deleted_at IS NULL ORDER BY created_at DESC`
2. Loading state shows spinner while fetching
3. Tasks populate FlatList after load completes
4. Pull-to-refresh gesture re-queries database
5. Error state if query fails

## Tasks / Subtasks
- [x] Add `loadTasks` function to task store (AC: 1, 2, 3, 5)
  - [x] Modify `TaskStore` interface to include `loadTasks: () => Promise<void>` action
  - [x] Import `supabase` client from `src/lib/supabase`
  - [x] Get `user_id` from users table (same pattern as Story 2.3):
    - Get `session` from `useAuthStore.getState().session`
    - Check if `session?.user?.id` exists, throw error if not
    - Query: `supabase.from('users').select('id').eq('auth_id', session.user.id).single()`
    - Extract `user_id` from query result
    - Handle error case: If query fails, throw error (user not found indicates auth issue)
  - [x] Query tasks from Supabase:
    - Query: `supabase.from('tasks').select('*').eq('user_id', userId).is('deleted_at', null).order('created_at', { ascending: false })`
    - Handle query result: Check for `error` property
    - If error: Throw error for UI handling
    - If success: Update store state with `set((state) => ({ tasks: data }))`
    - Note: Supabase query returns array of task objects matching Task interface
- [x] Add loading state to task store (AC: 2)
  - [x] Add `isLoading: boolean` to `TaskStore` interface
  - [x] Initialize `isLoading: false` in store creation
  - [x] Set `isLoading: true` at start of `loadTasks` function
  - [x] Set `isLoading: false` in `finally` block (after query completes or errors)
- [x] Add error state to task store (AC: 5)
  - [x] Add `loadError: string | null` to `TaskStore` interface
  - [x] Initialize `loadError: null` in store creation
  - [x] Clear `loadError` at start of `loadTasks` function: `set({ loadError: null })`
  - [x] Set `loadError` message if query fails: `catch (error) { set({ loadError: error.message || 'Failed to load tasks' }) }`
- [x] Call `loadTasks` on MainScreen mount (AC: 1, 2, 3)
  - [x] Import `useTaskStore` hook in `MainScreen.tsx`
  - [x] Get `loadTasks` and `isLoading` from store: `const { loadTasks, isLoading, loadError } = useTaskStore((state) => ({ loadTasks: state.loadTasks, isLoading: state.isLoading, loadError: state.loadError }))`
  - [x] Use `useEffect` hook to call `loadTasks()` when component mounts
  - [x] Add dependency array: `[loadTasks]` (or empty array if loadTasks is stable)
  - [x] Handle errors: Display error message if `loadError` is set
- [x] Display loading spinner in MainScreen (AC: 2)
  - [x] Import `ActivityIndicator` from `react-native` (already imported)
  - [x] Show spinner when `isLoading === true`
  - [x] Replace empty state or task list with spinner while loading
  - [x] Condition: `{isLoading && !refreshing ? <ActivityIndicator size="large" /> : <FlatList ... />}`
- [x] Implement pull-to-refresh on FlatList (AC: 4)
  - [x] Add `refreshing` state: `const [refreshing, setRefreshing] = useState(false)`
  - [x] Create `onRefresh` handler function:
    - Set `refreshing` to `true`
    - Call `loadTasks()`
    - Set `refreshing` to `false` after `loadTasks` completes (use `await` and `finally` or callback)
  - [x] Add `refreshControl` prop to FlatList:
    - Import `RefreshControl` from `react-native`
    - Add prop: `refreshControl={<RefreshControl refreshing={refreshing} onRefresh={onRefresh} />}`
  - [x] Note: `RefreshControl` provides native visual feedback during refresh (spinner animation), so no separate loading indicator needed during pull-to-refresh
- [x] Display error state if load fails (AC: 5)
  - [x] Check if `loadError` is not null from store
  - [x] Display error message inline in UI (recommended for consistency with loading state UI pattern):
    - Show error text when `loadError` is set
    - Condition: `{loadError ? <Text style={styles.errorText}>{loadError}</Text> : null}`
    - Include retry instruction: "Failed to load tasks. Pull down to retry."
    - Allow pull-to-refresh to retry (RefreshControl will handle retry)
  - [x] Note: Inline error display matches the loading state UI pattern (ActivityIndicator), providing consistent UX
- [x] Handle empty state after load completes (AC: 3)
  - [x] Ensure empty state shows when `isLoading === false` and `tasks.length === 0`
  - [x] Empty state should not show while loading
  - [x] Empty state text: "ðŸŒ… Add your first task" (existing)

## Dev Notes

### Previous Story Insights
[Source: Story 2.3 completion notes]

**Key Learnings from Story 2.3:**
- Task store already has `addTask` function with Supabase integration
- User ID resolution pattern established: Query `users` table with `auth_id = session.user.id` to get `user_id`
- Task interface includes optional `user_id` field (populated when saved to Supabase)
- Tasks stored in Zustand store in `tasks` array
- Server-generated IDs sync to local state after successful save
- Error handling pattern: Throw errors from store, catch in UI component with `Alert.alert()`

**Current Implementation:**
- `src/stores/taskStore.ts` - Has `addTask` with Supabase insert, needs `loadTasks` function
- `src/stores/authStore.ts` - Provides `session` state with authenticated user information
- `src/screens/MainScreen.tsx` - Displays tasks from store, has FAB button and task creation modal
- `src/lib/supabase.ts` - Supabase client configured and ready for database operations
- Migration file: `supabase/migrations/002_tasks_table.sql` - Tasks table exists with RLS policies

### Database Schema Context
[Source: architecture/database-schema-data-model.md, supabase/migrations/002_tasks_table.sql]

**Tasks Table Schema:**
The tasks table has the following structure:

**Primary Key & Foreign Key:**
- `id UUID PRIMARY KEY DEFAULT uuid_generate_v4()` - Primary key, auto-generated by database
- `user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE` - Foreign key to users table

**Task Content:**
- `text VARCHAR(500) NOT NULL` - Task content (database field name is `text`, but UI displays as "title" to users)

**Task Status:**
- `status VARCHAR(20) NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'completed', 'archived'))` - Enum for task state
  - `open`: Task exists, not yet completed (default)
  - `completed`: Task marked done by user
  - `archived`: Task moved to archive (for future features)

**Timestamps:**
- `created_at TIMESTAMP DEFAULT NOW()` - Record creation time
- `updated_at TIMESTAMP DEFAULT NOW()` - Last update time (auto-updated by database)
- `deleted_at TIMESTAMP DEFAULT NULL` - Soft delete timestamp (NULL if not deleted)

**Optional Fields (default to NULL):**
- `completed_at TIMESTAMP DEFAULT NULL` - Timestamp when task was completed
- `archived_at TIMESTAMP DEFAULT NULL` - Timestamp when task was archived
- `synced_at TIMESTAMP DEFAULT NULL` - Timestamp when task was last synced (for offline-first architecture, Story 2.4+)
- `emailed_at TIMESTAMP DEFAULT NULL` - Timestamp when task was included in sent email

**Row-Level Security (RLS):**
[Source: supabase/migrations/002_tasks_table.sql]

The tasks table has RLS enabled with the following SELECT policy:
```sql
CREATE POLICY "tasks_select_own" ON tasks
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = tasks.user_id 
      AND users.auth_id = auth.uid()
    )
  );
```

This means:
- Supabase automatically validates that the authenticated user can only query their own tasks
- The query `supabase.from('tasks').select('*').eq('user_id', userId)` will only return tasks belonging to the authenticated user
- No need for additional filtering beyond `user_id` and `deleted_at` checks

**Getting user_id from Session:**
To query tasks, we need the `user_id` (UUID from `users` table), not the `auth_id` (UUID from `auth.users` table). The session provides `session.user.id` which is the `auth_id`. We must query the users table to get the corresponding `user_id`:

```typescript
// Get user_id from users table
const { data: user, error: userError } = await supabase
  .from('users')
  .select('id')
  .eq('auth_id', session.user.id)
  .single();

if (userError || !user) {
  // Handle error - user not found (should not happen if authenticated)
  throw new Error(`User not found: ${userError?.message || 'No user record'}`);
}

const userId = user.id; // This is the user_id for tasks table
```

**Supabase Query Pattern:**
[Source: Story 2.3 implementation, architecture/database-schema-data-model.md]

The Supabase query pattern for loading tasks:

**Basic Query:**
```typescript
const { data, error } = await supabase
  .from('tasks')
  .select('*')
  .eq('user_id', userId)
  .is('deleted_at', null)
  .order('created_at', { ascending: false });

// Response on success: { 
//   data: [{ id, user_id, text, status, created_at, updated_at, deleted_at, ... }],
//   error: null 
// }

if (error) {
  // Handle error
  throw error;
}

// Update store with tasks
set({ tasks: data || [] });
```

**Query Fields:**
- `select('*')` returns all columns from tasks table
- `.eq('user_id', userId)` filters to user's tasks
- `.is('deleted_at', null)` filters out soft-deleted tasks
- `.order('created_at', { ascending: false })` orders by newest first (DESC)

**Note:** Supabase automatically handles RLS policies, so we don't need to worry about users accessing other users' tasks. The query will only return tasks for the authenticated user.

### State Management Architecture
[Source: architecture/offline-first-sync-architecture.md, src/stores/taskStore.ts]

**Zustand Store Pattern:**
The task store follows the Zustand pattern established in `authStore.ts`:
- Use `create` from `zustand` to create store
- Define TypeScript interface for store state and actions
- Use immutable updates for state (spread operator for arrays)
- Export custom hook: `useTaskStore`

**Current TaskStore Interface:**
[Source: src/stores/taskStore.ts]

```typescript
interface TaskStore {
  tasks: Task[];
  addTask: (text: string) => Promise<void>;
  // Need to add:
  // loadTasks: () => Promise<void>;
  // isLoading: boolean;
  // loadError: string | null;
}
```

**Loading State Pattern:**
For Story 2.4, we add loading and error state:
```typescript
interface TaskStore {
  tasks: Task[];
  isLoading: boolean;
  loadError: string | null;
  addTask: (text: string) => Promise<void>;
  loadTasks: () => Promise<void>;
}
```

**Implementation Pattern:**
```typescript
loadTasks: async () => {
  const session = useAuthStore.getState().session;
  
  if (!session?.user?.id) {
    set({ loadError: 'No authenticated session found' });
    return;
  }

  // Get user_id from users table
  const { data: user, error: userError } = await supabase
    .from('users')
    .select('id')
    .eq('auth_id', session.user.id)
    .single();

  if (userError || !user) {
    set({ loadError: `User not found: ${userError?.message || 'No user record'}` });
    return;
  }

  const userId = user.id;

  // Set loading state
  set({ isLoading: true, loadError: null });

  try {
    // Query tasks
    const { data, error } = await supabase
      .from('tasks')
      .select('*')
      .eq('user_id', userId)
      .is('deleted_at', null)
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    // Update tasks in store (replaces all tasks - no deduplication needed)
    set({ tasks: data || [], isLoading: false });
  } catch (error: any) {
    set({ 
      loadError: error.message || 'Failed to load tasks',
      isLoading: false 
    });
  }
}
```

### Error Handling
[Source: Story 2.3 implementation, MainScreen.tsx patterns]

**Supabase Error Pattern:**
Supabase queries return `{ data, error }`:
```typescript
const { data, error } = await supabase.from('tasks').select('*')...;

if (error) {
  // Handle error
  console.error('Query failed:', error);
  // Set error state, show error to user
}
```

**Common Error Cases:**
1. **Network Error**: No internet connection â†’ `error` will indicate network failure
2. **RLS Policy Violation**: Invalid `user_id` or unauthorized â†’ `error` will indicate policy violation (should not happen with correct user_id)
3. **User Not Found**: Querying users table fails â†’ User may not be properly authenticated

**Error Display:**
[Source: MainScreen.tsx patterns from Story 2.3]

React Native `Alert.alert()` pattern:
```typescript
Alert.alert(
  'Error',
  'Failed to load tasks. Please try again.',
  [{ text: 'OK' }]
);
```

**Recommended: Inline Error Display** (for consistency with loading state UI):
```typescript
{isLoading ? (
  <ActivityIndicator size="large" color="#2563eb" />
) : loadError ? (
  <View style={styles.errorContainer}>
    <Text style={styles.errorText}>{loadError}</Text>
    <Text style={styles.errorHint}>Pull down to retry</Text>
  </View>
) : tasks.length === 0 ? (
  <Text style={styles.emptyState}>ðŸŒ… Add your first task</Text>
) : (
  <FlatList data={tasks} ... />
)}
```

This pattern provides consistent UX where loading and error states are both displayed inline, matching the visual pattern of the ActivityIndicator.

### React Native Component Patterns
[Source: MainScreen.tsx, React Native documentation]

**useEffect Hook for Mount Behavior:**
```typescript
import { useEffect } from 'react';

useEffect(() => {
  loadTasks();
}, [loadTasks]); // Empty array if loadTasks is stable, or include dependencies
```

**Pull-to-Refresh Pattern:**
[Source: React Native FlatList documentation]

```typescript
import { RefreshControl } from 'react-native';

const [refreshing, setRefreshing] = useState(false);

const onRefresh = async () => {
  setRefreshing(true);
  try {
    await loadTasks();
  } finally {
    setRefreshing(false);
  }
};

<FlatList
  data={tasks}
  keyExtractor={(item) => item.id}
  renderItem={renderTaskItem}
  refreshControl={
    <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
  }
/>
```

**Loading State UI with Error Handling:**
```typescript
{isLoading ? (
  <ActivityIndicator size="large" color="#2563eb" />
) : loadError ? (
  <View style={styles.errorContainer}>
    <Text style={styles.errorText}>{loadError}</Text>
    <Text style={styles.errorHint}>Pull down to retry</Text>
  </View>
) : tasks.length === 0 ? (
  <Text style={styles.emptyState}>ðŸŒ… Add your first task</Text>
) : (
  <FlatList data={tasks} ... />
)}
```

This pattern provides consistent inline UI for loading, error, empty, and content states.

### Testing Requirements
[Source: architecture/testing-strategy.md]

**Manual Testing:**
Story 2.4 focuses on manual testing:
- Unit tests not required for MVP story (testing framework setup is Story 1.2.5, optional)
- Manual verification of all acceptance criteria
- Cross-platform testing: iOS and Android (Expo)
- Test both success and error scenarios

**Test Scenarios:**
1. **Happy Path**: Open app â†’ Verify spinner shows â†’ Verify tasks load â†’ Verify tasks appear in list
2. **Empty State**: Delete all tasks â†’ Close app â†’ Reopen â†’ Verify empty state shows
3. **Error Handling**: Disable network â†’ Open app â†’ Verify error message â†’ Re-enable network â†’ Pull to refresh â†’ Verify tasks load
4. **Pull-to-Refresh**: Load tasks â†’ Pull down on list â†’ Verify refresh spinner â†’ Verify tasks reload
5. **Data Verification**: Add tasks in Story 2.3 â†’ Close app â†’ Reopen â†’ Verify all tasks load with correct data

### Project Structure Notes
[Source: Story 2.3, docs/architecture]

**Directory Structure:**
- Source code: `src/`
- Stores: `src/stores/` - Zustand stores
- Screens: `src/screens/` - Screen components
- Libraries: `src/lib/` - Supabase client and utilities

**Files to Modify:**
- `src/stores/taskStore.ts` - Add `loadTasks` function, `isLoading`, `loadError` state
- `src/screens/MainScreen.tsx` - Add `useEffect` to call `loadTasks`, add loading/error UI, add pull-to-refresh

**File Organization:**
- Keep Supabase query logic in task store (separation of concerns)
- UI loading/error states in MainScreen component
- Session access via `useAuthStore` hook (established pattern)

### Known Constraints
- Story 2.4 does NOT implement offline-first sync queue or AsyncStorage persistence (that's future story)
- Tasks are loaded fresh from Supabase on every app open
- No local caching of tasks (acceptable for MVP, offline-first sync comes later)
- Loading state shows on every mount (acceptable UX for MVP)
- Pull-to-refresh always queries Supabase (no local cache check)

## Testing

**Manual Test Steps:**
1. Open app and sign in (ensure authenticated session exists)
2. Verify user has tasks in Supabase (add tasks via Story 2.3 if needed)
3. Close app completely (kill process, not just background)
4. Reopen app â†’ Verify loading spinner appears
5. Verify tasks appear in list after load completes
6. Verify tasks are ordered by newest first (`created_at DESC`)
7. Test pull-to-refresh: Pull down on task list â†’ Verify refresh spinner â†’ Verify tasks reload
8. Test error scenario: Disable WiFi/mobile data â†’ Close app â†’ Reopen â†’ Verify error message appears
9. Test empty state: Delete all tasks (or test with new user) â†’ Close app â†’ Reopen â†’ Verify empty state shows
10. Test with multiple tasks: Add 5+ tasks â†’ Close app â†’ Reopen â†’ Verify all tasks load correctly

**Success Criteria:**
- Tasks load from Supabase on app open
- Loading state shows spinner while fetching
- Tasks appear in list ordered by newest first
- Pull-to-refresh reloads tasks from database
- Error handling works: Network errors show error message
- Empty state shows when no tasks exist
- No duplicate tasks or data inconsistencies

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | | Initial story creation | Scrum Master |
| 2025-01-27 | | Updated error handling to recommend inline display for consistency with loading state UI (per PO validation) | Scrum Master |
| 2025-01-27 | | Added notes about RefreshControl visual feedback and task replacement pattern (per PO validation) | Scrum Master |
| 2025-01-27 | | Status updated to Approved - Story validated by PO (GO status), all PO feedback incorporated, ready for implementation | Scrum Master |
| 2025-01-27 | | Status updated to Done - All acceptance criteria met, QA review passed (Quality Score: 95/100), implementation complete and production-ready | Scrum Master |

## Dev Agent Record

### Agent Model Used
Claude Sonnet 4.5 (via Cursor Composer)

### Debug Log References
None

### Completion Notes List
- **Task Store Implementation**: Added `loadTasks` function to `src/stores/taskStore.ts` following the same user_id resolution pattern as `addTask` from Story 2.3. Function queries users table to get `user_id` from `auth_id`, then queries tasks table with filters for `user_id`, `deleted_at IS NULL`, and orders by `created_at DESC`.
- **Loading & Error States**: Added `isLoading: boolean` and `loadError: string | null` to TaskStore interface. Loading state is set to `true` at start of `loadTasks` and `false` after completion/error. Error state is cleared at start and set in catch block.
- **MainScreen Integration**: Added `useEffect` hook to call `loadTasks()` on component mount. Fixed Zustand selector infinite loop issue by splitting multi-value selector into individual selectors (prevents "Maximum update depth exceeded" error).
- **UI States**: Implemented conditional rendering for loading (ActivityIndicator on initial load only), error (inline error message with retry hint), empty state, and task list. FlatList is always rendered (except initial load with no tasks) to enable RefreshControl in all states using `ListEmptyComponent` prop.
- **Pull-to-Refresh**: Added `RefreshControl` to FlatList with `refreshing` state managed locally. RefreshControl works during refresh since FlatList remains visible. Added proper error handling in `onRefresh` handler.
- **Error Handling**: Error messages are displayed inline with consistent styling, showing error text and "Pull down to retry" hint. Errors are caught in store and set in `loadError` state for UI display.
- **Bug Fixes**: Fixed infinite re-render loop caused by Zustand multi-value selector returning new object on each render. Split into individual selectors to ensure stable references.

### File List
- `src/stores/taskStore.ts` - Modified: Added `loadTasks` function, `isLoading` and `loadError` state
- `src/screens/MainScreen.tsx` - Modified: Added `useEffect` to load tasks on mount, implemented loading/error UI states, added pull-to-refresh with RefreshControl

## QA Results

### Review Date: 2025-11-01

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

**Overall Assessment:** âœ… **EXCELLENT**

The implementation demonstrates solid engineering practices with proper error handling, state management, and UI patterns. Developer proactively fixed critical bugs (infinite loop, pull-to-refresh) during implementation, showing good quality awareness.

**Strengths:**
- Clean separation of concerns: store handles data logic, UI handles presentation
- Proper error handling with user-friendly messages
- Follows established patterns from Story 2.3
- Zustand selector optimization to prevent infinite loops
- Comprehensive loading/error/empty state handling
- Pull-to-refresh properly implemented with RefreshControl

**Code Patterns:**
- âœ… Consistent with existing Zustand store patterns
- âœ… Error handling follows established conventions
- âœ… UI state management is clear and maintainable
- âœ… TypeScript types are properly defined

### Requirements Traceability

**Acceptance Criteria Coverage:**
- âœ… **AC1**: Query on mount - `useEffect` calls `loadTasks()` on component mount
- âœ… **AC2**: Loading spinner - `ActivityIndicator` shows during initial load
- âœ… **AC3**: Tasks populate FlatList - Tasks loaded and displayed correctly
- âœ… **AC4**: Pull-to-refresh - `RefreshControl` implemented and functional
- âœ… **AC5**: Error state - Inline error display with retry hint

**Manual Test Verification:**
- âœ… Tasks load on app open
- âœ… Loading spinner appears
- âœ… Pull-to-refresh works with blue spinner
- âœ… Error handling displays properly

### Refactoring Performed

**No refactoring required** - Code quality is production-ready. Minor cleanup opportunity identified below.

### Compliance Check

- âœ… **Coding Standards**: Code follows React Native best practices and project patterns
- âœ… **Project Structure**: Files in correct locations (`src/stores/`, `src/screens/`)
- âœ… **Testing Strategy**: Manual testing acceptable per story requirements (MVP phase)
- âœ… **All ACs Met**: All 5 acceptance criteria fully implemented and verified

### Improvements Checklist

**Minor Cleanup (Optional):**
- [ ] Remove unused `get` parameter from Zustand store: `create<TaskStore>((set) => ({` (currently has `(set, get)` but `get` is unused)

**Future Enhancements (Not Required for MVP):**
- [ ] Consider adding unit tests when testing framework is established (Story 1.2.5)
- [ ] Consider optimistic UI updates for pull-to-refresh (keep existing tasks visible while refreshing)

### Security Review

âœ… **PASS** - No security concerns identified.

**Security Strengths:**
- RLS policies automatically enforce user isolation (no cross-user data access)
- User ID resolution uses authenticated session (cannot be spoofed)
- No hardcoded secrets or credentials
- Proper error messages that don't leak sensitive information

### Performance Considerations

âœ… **PASS** - Performance is acceptable for MVP.

**Performance Notes:**
- Single query on mount (acceptable for MVP)
- No unnecessary re-renders (Zustand selector optimization prevents loops)
- Pull-to-refresh replaces entire task list (acceptable; future optimization could use incremental updates)
- No caching yet (acceptable per story constraints; offline-first sync planned for future)

**Future Optimization Opportunities:**
- Implement local caching to reduce network calls
- Consider pagination for large task lists (future enhancement)
- Incremental sync instead of full reload (future enhancement)

### Testability Evaluation

âœ… **EXCELLENT** - Code is highly testable.

**Controllability:** âœ… High
- Store actions can be called directly
- UI states can be controlled via store state
- Error conditions can be simulated

**Observability:** âœ… High
- Store state is observable via Zustand hooks
- Error states are clearly surfaced in UI
- Loading states are visible to users

**Debuggability:** âœ… High
- Clear error messages
- Proper TypeScript types
- Code is well-structured and readable

### Files Modified During Review

**No files modified** - Implementation is complete and production-ready.

### Gate Status

**Gate: PASS** â†’ `docs/qa/gates/2.4-load-tasks-on-app-open.yml`

**Quality Score:** 95/100

**Rationale:** All acceptance criteria met, code quality is excellent, security is solid, and implementation follows best practices. Minor cleanup opportunity (unused parameter) does not affect functionality and is optional.

### Recommended Status

âœ… **Ready for Done** - Story is complete and production-ready. No blocking issues identified.

