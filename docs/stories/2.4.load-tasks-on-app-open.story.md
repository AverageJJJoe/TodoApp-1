# Story 2.4: Load Tasks on App Open

## Status
Approved

## Story
**As a** user,  
**I want to** see all my tasks when I open the app,  
**So that** I can review what I've captured

## Acceptance Criteria
1. On MainScreen mount, query: `SELECT * FROM tasks WHERE user_id = ? AND deleted_at IS NULL ORDER BY created_at DESC`
2. Loading state shows spinner while fetching
3. Tasks populate FlatList after load completes
4. Pull-to-refresh gesture re-queries database
5. Error state if query fails

## Tasks / Subtasks
- [ ] Add `loadTasks` function to task store (AC: 1, 2, 3, 5)
  - [ ] Modify `TaskStore` interface to include `loadTasks: () => Promise<void>` action
  - [ ] Import `supabase` client from `src/lib/supabase`
  - [ ] Get `user_id` from users table (same pattern as Story 2.3):
    - Get `session` from `useAuthStore.getState().session`
    - Check if `session?.user?.id` exists, throw error if not
    - Query: `supabase.from('users').select('id').eq('auth_id', session.user.id).single()`
    - Extract `user_id` from query result
    - Handle error case: If query fails, throw error (user not found indicates auth issue)
  - [ ] Query tasks from Supabase:
    - Query: `supabase.from('tasks').select('*').eq('user_id', userId).is('deleted_at', null).order('created_at', { ascending: false })`
    - Handle query result: Check for `error` property
    - If error: Throw error for UI handling
    - If success: Update store state with `set((state) => ({ tasks: data }))`
    - Note: Supabase query returns array of task objects matching Task interface
- [ ] Add loading state to task store (AC: 2)
  - [ ] Add `isLoading: boolean` to `TaskStore` interface
  - [ ] Initialize `isLoading: false` in store creation
  - [ ] Set `isLoading: true` at start of `loadTasks` function
  - [ ] Set `isLoading: false` in `finally` block (after query completes or errors)
- [ ] Add error state to task store (AC: 5)
  - [ ] Add `loadError: string | null` to `TaskStore` interface
  - [ ] Initialize `loadError: null` in store creation
  - [ ] Clear `loadError` at start of `loadTasks` function: `set({ loadError: null })`
  - [ ] Set `loadError` message if query fails: `catch (error) { set({ loadError: error.message || 'Failed to load tasks' }) }`
- [ ] Call `loadTasks` on MainScreen mount (AC: 1, 2, 3)
  - [ ] Import `useTaskStore` hook in `MainScreen.tsx`
  - [ ] Get `loadTasks` and `isLoading` from store: `const { loadTasks, isLoading, loadError } = useTaskStore((state) => ({ loadTasks: state.loadTasks, isLoading: state.isLoading, loadError: state.loadError }))`
  - [ ] Use `useEffect` hook to call `loadTasks()` when component mounts
  - [ ] Add dependency array: `[loadTasks]` (or empty array if loadTasks is stable)
  - [ ] Handle errors: Display error message if `loadError` is set
- [ ] Display loading spinner in MainScreen (AC: 2)
  - [ ] Import `ActivityIndicator` from `react-native` (already imported)
  - [ ] Show spinner when `isLoading === true`
  - [ ] Replace empty state or task list with spinner while loading
  - [ ] Condition: `{isLoading ? <ActivityIndicator size="large" /> : (tasks.length === 0 ? <Text>ðŸŒ… Add your first task</Text> : <FlatList ... />)}`
- [ ] Implement pull-to-refresh on FlatList (AC: 4)
  - [ ] Add `refreshing` state: `const [refreshing, setRefreshing] = useState(false)`
  - [ ] Create `onRefresh` handler function:
    - Set `refreshing` to `true`
    - Call `loadTasks()`
    - Set `refreshing` to `false` after `loadTasks` completes (use `await` and `finally` or callback)
  - [ ] Add `refreshControl` prop to FlatList:
    - Import `RefreshControl` from `react-native`
    - Add prop: `refreshControl={<RefreshControl refreshing={refreshing} onRefresh={onRefresh} />}`
  - [ ] Note: `RefreshControl` provides native visual feedback during refresh (spinner animation), so no separate loading indicator needed during pull-to-refresh
- [ ] Display error state if load fails (AC: 5)
  - [ ] Check if `loadError` is not null from store
  - [ ] Display error message inline in UI (recommended for consistency with loading state UI pattern):
    - Show error text when `loadError` is set
    - Condition: `{loadError ? <Text style={styles.errorText}>{loadError}</Text> : null}`
    - Include retry instruction: "Failed to load tasks. Pull down to retry."
    - Allow pull-to-refresh to retry (RefreshControl will handle retry)
  - [ ] Note: Inline error display matches the loading state UI pattern (ActivityIndicator), providing consistent UX
- [ ] Handle empty state after load completes (AC: 3)
  - [ ] Ensure empty state shows when `isLoading === false` and `tasks.length === 0`
  - [ ] Empty state should not show while loading
  - [ ] Empty state text: "ðŸŒ… Add your first task" (existing)

## Dev Notes

### Previous Story Insights
[Source: Story 2.3 completion notes]

**Key Learnings from Story 2.3:**
- Task store already has `addTask` function with Supabase integration
- User ID resolution pattern established: Query `users` table with `auth_id = session.user.id` to get `user_id`
- Task interface includes optional `user_id` field (populated when saved to Supabase)
- Tasks stored in Zustand store in `tasks` array
- Server-generated IDs sync to local state after successful save
- Error handling pattern: Throw errors from store, catch in UI component with `Alert.alert()`

**Current Implementation:**
- `src/stores/taskStore.ts` - Has `addTask` with Supabase insert, needs `loadTasks` function
- `src/stores/authStore.ts` - Provides `session` state with authenticated user information
- `src/screens/MainScreen.tsx` - Displays tasks from store, has FAB button and task creation modal
- `src/lib/supabase.ts` - Supabase client configured and ready for database operations
- Migration file: `supabase/migrations/002_tasks_table.sql` - Tasks table exists with RLS policies

### Database Schema Context
[Source: architecture/database-schema-data-model.md, supabase/migrations/002_tasks_table.sql]

**Tasks Table Schema:**
The tasks table has the following structure:

**Primary Key & Foreign Key:**
- `id UUID PRIMARY KEY DEFAULT uuid_generate_v4()` - Primary key, auto-generated by database
- `user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE` - Foreign key to users table

**Task Content:**
- `text VARCHAR(500) NOT NULL` - Task content (database field name is `text`, but UI displays as "title" to users)

**Task Status:**
- `status VARCHAR(20) NOT NULL DEFAULT 'open' CHECK (status IN ('open', 'completed', 'archived'))` - Enum for task state
  - `open`: Task exists, not yet completed (default)
  - `completed`: Task marked done by user
  - `archived`: Task moved to archive (for future features)

**Timestamps:**
- `created_at TIMESTAMP DEFAULT NOW()` - Record creation time
- `updated_at TIMESTAMP DEFAULT NOW()` - Last update time (auto-updated by database)
- `deleted_at TIMESTAMP DEFAULT NULL` - Soft delete timestamp (NULL if not deleted)

**Optional Fields (default to NULL):**
- `completed_at TIMESTAMP DEFAULT NULL` - Timestamp when task was completed
- `archived_at TIMESTAMP DEFAULT NULL` - Timestamp when task was archived
- `synced_at TIMESTAMP DEFAULT NULL` - Timestamp when task was last synced (for offline-first architecture, Story 2.4+)
- `emailed_at TIMESTAMP DEFAULT NULL` - Timestamp when task was included in sent email

**Row-Level Security (RLS):**
[Source: supabase/migrations/002_tasks_table.sql]

The tasks table has RLS enabled with the following SELECT policy:
```sql
CREATE POLICY "tasks_select_own" ON tasks
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM users 
      WHERE users.id = tasks.user_id 
      AND users.auth_id = auth.uid()
    )
  );
```

This means:
- Supabase automatically validates that the authenticated user can only query their own tasks
- The query `supabase.from('tasks').select('*').eq('user_id', userId)` will only return tasks belonging to the authenticated user
- No need for additional filtering beyond `user_id` and `deleted_at` checks

**Getting user_id from Session:**
To query tasks, we need the `user_id` (UUID from `users` table), not the `auth_id` (UUID from `auth.users` table). The session provides `session.user.id` which is the `auth_id`. We must query the users table to get the corresponding `user_id`:

```typescript
// Get user_id from users table
const { data: user, error: userError } = await supabase
  .from('users')
  .select('id')
  .eq('auth_id', session.user.id)
  .single();

if (userError || !user) {
  // Handle error - user not found (should not happen if authenticated)
  throw new Error(`User not found: ${userError?.message || 'No user record'}`);
}

const userId = user.id; // This is the user_id for tasks table
```

**Supabase Query Pattern:**
[Source: Story 2.3 implementation, architecture/database-schema-data-model.md]

The Supabase query pattern for loading tasks:

**Basic Query:**
```typescript
const { data, error } = await supabase
  .from('tasks')
  .select('*')
  .eq('user_id', userId)
  .is('deleted_at', null)
  .order('created_at', { ascending: false });

// Response on success: { 
//   data: [{ id, user_id, text, status, created_at, updated_at, deleted_at, ... }],
//   error: null 
// }

if (error) {
  // Handle error
  throw error;
}

// Update store with tasks
set({ tasks: data || [] });
```

**Query Fields:**
- `select('*')` returns all columns from tasks table
- `.eq('user_id', userId)` filters to user's tasks
- `.is('deleted_at', null)` filters out soft-deleted tasks
- `.order('created_at', { ascending: false })` orders by newest first (DESC)

**Note:** Supabase automatically handles RLS policies, so we don't need to worry about users accessing other users' tasks. The query will only return tasks for the authenticated user.

### State Management Architecture
[Source: architecture/offline-first-sync-architecture.md, src/stores/taskStore.ts]

**Zustand Store Pattern:**
The task store follows the Zustand pattern established in `authStore.ts`:
- Use `create` from `zustand` to create store
- Define TypeScript interface for store state and actions
- Use immutable updates for state (spread operator for arrays)
- Export custom hook: `useTaskStore`

**Current TaskStore Interface:**
[Source: src/stores/taskStore.ts]

```typescript
interface TaskStore {
  tasks: Task[];
  addTask: (text: string) => Promise<void>;
  // Need to add:
  // loadTasks: () => Promise<void>;
  // isLoading: boolean;
  // loadError: string | null;
}
```

**Loading State Pattern:**
For Story 2.4, we add loading and error state:
```typescript
interface TaskStore {
  tasks: Task[];
  isLoading: boolean;
  loadError: string | null;
  addTask: (text: string) => Promise<void>;
  loadTasks: () => Promise<void>;
}
```

**Implementation Pattern:**
```typescript
loadTasks: async () => {
  const session = useAuthStore.getState().session;
  
  if (!session?.user?.id) {
    set({ loadError: 'No authenticated session found' });
    return;
  }

  // Get user_id from users table
  const { data: user, error: userError } = await supabase
    .from('users')
    .select('id')
    .eq('auth_id', session.user.id)
    .single();

  if (userError || !user) {
    set({ loadError: `User not found: ${userError?.message || 'No user record'}` });
    return;
  }

  const userId = user.id;

  // Set loading state
  set({ isLoading: true, loadError: null });

  try {
    // Query tasks
    const { data, error } = await supabase
      .from('tasks')
      .select('*')
      .eq('user_id', userId)
      .is('deleted_at', null)
      .order('created_at', { ascending: false });

    if (error) {
      throw error;
    }

    // Update tasks in store (replaces all tasks - no deduplication needed)
    set({ tasks: data || [], isLoading: false });
  } catch (error: any) {
    set({ 
      loadError: error.message || 'Failed to load tasks',
      isLoading: false 
    });
  }
}
```

### Error Handling
[Source: Story 2.3 implementation, MainScreen.tsx patterns]

**Supabase Error Pattern:**
Supabase queries return `{ data, error }`:
```typescript
const { data, error } = await supabase.from('tasks').select('*')...;

if (error) {
  // Handle error
  console.error('Query failed:', error);
  // Set error state, show error to user
}
```

**Common Error Cases:**
1. **Network Error**: No internet connection â†’ `error` will indicate network failure
2. **RLS Policy Violation**: Invalid `user_id` or unauthorized â†’ `error` will indicate policy violation (should not happen with correct user_id)
3. **User Not Found**: Querying users table fails â†’ User may not be properly authenticated

**Error Display:**
[Source: MainScreen.tsx patterns from Story 2.3]

React Native `Alert.alert()` pattern:
```typescript
Alert.alert(
  'Error',
  'Failed to load tasks. Please try again.',
  [{ text: 'OK' }]
);
```

**Recommended: Inline Error Display** (for consistency with loading state UI):
```typescript
{isLoading ? (
  <ActivityIndicator size="large" color="#2563eb" />
) : loadError ? (
  <View style={styles.errorContainer}>
    <Text style={styles.errorText}>{loadError}</Text>
    <Text style={styles.errorHint}>Pull down to retry</Text>
  </View>
) : tasks.length === 0 ? (
  <Text style={styles.emptyState}>ðŸŒ… Add your first task</Text>
) : (
  <FlatList data={tasks} ... />
)}
```

This pattern provides consistent UX where loading and error states are both displayed inline, matching the visual pattern of the ActivityIndicator.

### React Native Component Patterns
[Source: MainScreen.tsx, React Native documentation]

**useEffect Hook for Mount Behavior:**
```typescript
import { useEffect } from 'react';

useEffect(() => {
  loadTasks();
}, [loadTasks]); // Empty array if loadTasks is stable, or include dependencies
```

**Pull-to-Refresh Pattern:**
[Source: React Native FlatList documentation]

```typescript
import { RefreshControl } from 'react-native';

const [refreshing, setRefreshing] = useState(false);

const onRefresh = async () => {
  setRefreshing(true);
  try {
    await loadTasks();
  } finally {
    setRefreshing(false);
  }
};

<FlatList
  data={tasks}
  keyExtractor={(item) => item.id}
  renderItem={renderTaskItem}
  refreshControl={
    <RefreshControl refreshing={refreshing} onRefresh={onRefresh} />
  }
/>
```

**Loading State UI with Error Handling:**
```typescript
{isLoading ? (
  <ActivityIndicator size="large" color="#2563eb" />
) : loadError ? (
  <View style={styles.errorContainer}>
    <Text style={styles.errorText}>{loadError}</Text>
    <Text style={styles.errorHint}>Pull down to retry</Text>
  </View>
) : tasks.length === 0 ? (
  <Text style={styles.emptyState}>ðŸŒ… Add your first task</Text>
) : (
  <FlatList data={tasks} ... />
)}
```

This pattern provides consistent inline UI for loading, error, empty, and content states.

### Testing Requirements
[Source: architecture/testing-strategy.md]

**Manual Testing:**
Story 2.4 focuses on manual testing:
- Unit tests not required for MVP story (testing framework setup is Story 1.2.5, optional)
- Manual verification of all acceptance criteria
- Cross-platform testing: iOS and Android (Expo)
- Test both success and error scenarios

**Test Scenarios:**
1. **Happy Path**: Open app â†’ Verify spinner shows â†’ Verify tasks load â†’ Verify tasks appear in list
2. **Empty State**: Delete all tasks â†’ Close app â†’ Reopen â†’ Verify empty state shows
3. **Error Handling**: Disable network â†’ Open app â†’ Verify error message â†’ Re-enable network â†’ Pull to refresh â†’ Verify tasks load
4. **Pull-to-Refresh**: Load tasks â†’ Pull down on list â†’ Verify refresh spinner â†’ Verify tasks reload
5. **Data Verification**: Add tasks in Story 2.3 â†’ Close app â†’ Reopen â†’ Verify all tasks load with correct data

### Project Structure Notes
[Source: Story 2.3, docs/architecture]

**Directory Structure:**
- Source code: `src/`
- Stores: `src/stores/` - Zustand stores
- Screens: `src/screens/` - Screen components
- Libraries: `src/lib/` - Supabase client and utilities

**Files to Modify:**
- `src/stores/taskStore.ts` - Add `loadTasks` function, `isLoading`, `loadError` state
- `src/screens/MainScreen.tsx` - Add `useEffect` to call `loadTasks`, add loading/error UI, add pull-to-refresh

**File Organization:**
- Keep Supabase query logic in task store (separation of concerns)
- UI loading/error states in MainScreen component
- Session access via `useAuthStore` hook (established pattern)

### Known Constraints
- Story 2.4 does NOT implement offline-first sync queue or AsyncStorage persistence (that's future story)
- Tasks are loaded fresh from Supabase on every app open
- No local caching of tasks (acceptable for MVP, offline-first sync comes later)
- Loading state shows on every mount (acceptable UX for MVP)
- Pull-to-refresh always queries Supabase (no local cache check)

## Testing

**Manual Test Steps:**
1. Open app and sign in (ensure authenticated session exists)
2. Verify user has tasks in Supabase (add tasks via Story 2.3 if needed)
3. Close app completely (kill process, not just background)
4. Reopen app â†’ Verify loading spinner appears
5. Verify tasks appear in list after load completes
6. Verify tasks are ordered by newest first (`created_at DESC`)
7. Test pull-to-refresh: Pull down on task list â†’ Verify refresh spinner â†’ Verify tasks reload
8. Test error scenario: Disable WiFi/mobile data â†’ Close app â†’ Reopen â†’ Verify error message appears
9. Test empty state: Delete all tasks (or test with new user) â†’ Close app â†’ Reopen â†’ Verify empty state shows
10. Test with multiple tasks: Add 5+ tasks â†’ Close app â†’ Reopen â†’ Verify all tasks load correctly

**Success Criteria:**
- Tasks load from Supabase on app open
- Loading state shows spinner while fetching
- Tasks appear in list ordered by newest first
- Pull-to-refresh reloads tasks from database
- Error handling works: Network errors show error message
- Empty state shows when no tasks exist
- No duplicate tasks or data inconsistencies

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-27 | | Initial story creation | Scrum Master |
| 2025-01-27 | | Updated error handling to recommend inline display for consistency with loading state UI (per PO validation) | Scrum Master |
| 2025-01-27 | | Added notes about RefreshControl visual feedback and task replacement pattern (per PO validation) | Scrum Master |
| 2025-01-27 | | Status updated to Approved - Story validated by PO (GO status), all PO feedback incorporated, ready for implementation | Scrum Master |

## Dev Agent Record

### Agent Model Used
_(To be filled by dev agent)_

### Debug Log References
_(To be filled by dev agent if needed)_

### Completion Notes List
_(To be filled by dev agent)_

### File List
_(To be filled by dev agent)_

## QA Results

_(To be filled by QA agent)_

